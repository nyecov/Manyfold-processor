# Token Efficiency Improvement Plan v2

**Created**: 2026-01-30
**Baseline Commit**: `3395d359ea3464832f3e6bc5e1607ddf8b42da4e`
**Status**: Phase 2 Complete (Shared Library & Hash Skips Implemented)

---

## Phase 1: Complete Script Coverage (High Priority) ✅ DONE

### Goal
Convert remaining manual workflows to headless Rust scripts.

| Workflow | Script to Create | Token Savings | Status |
|----------|-----------------|---------------|--------|
| `audit_consistency` | `check_consistency.rs` | ~15,000/run | ✅ |
| `audit_constants` | `check_constants.rs` | ~8,000/run | ✅ |
| `audit_context` | `check_context.rs` | ~12,000/run | ✅ |
| `audit_infrastructure` | `check_infrastructure.rs` | ~8,000/run | ✅ |

**Estimated Total Savings**: ~43,000 tokens/full audit

---

## Phase 1.5: Root Workflow Optimization (HIGH PRIORITY) ✅ DONE

### Problem Statement

The `/audit_tool_alignment` ROOT workflow costs **~27,000 tokens** per run. It is:
- **Mandatory**: Prevents garbage-in-garbage-out from misaligned tools
- **Agent-Only**: Requires semantic understanding (cannot be fully headless)
- **Wasteful**: Re-runs even when nothing has changed

### Goal

Implement a **Hash-Based Skip Condition** that:
1. Detects when tools/workflows are unchanged
2. Skips the expensive agent audit in those cases
3. **Guarantees no false negatives** (never skips when audit is needed)

---

### Design Decision: Why Hash-Based (Option B)?

| Approach | Pros | Cons | Safety |
|----------|------|------|--------|
| **Git-Based** | Simple, built-in | Only detects committed changes; misses uncommitted work | ⚠️ False negatives possible |
| **Hash-Based** | Detects ANY file change | Requires cache management | ✅ Safe |
| **Partial Headless** | Some structural checks | Complex; still needs agent for semantics | ✅ Safe but incomplete |

**Chosen**: Hash-Based — safest option with no false negatives.

---

### Implementation Architecture

#### 1. New Binary: `check_tool_alignment_skip.rs`

Location: `.agent/tools/src/bin/check_tool_alignment_skip.rs`

```rust
//! Hash-based skip detection for /audit_tool_alignment
//! 
//! Exit Codes:
//!   0 = Skip audit (cached PASS, hash matches)
//!   1 = Skip audit but warn (cached FAIL, hash matches)
//!   2 = Run full audit (hash mismatch or no cache)

use sha2::{Sha256, Digest};
use std::{fs, path::Path, process::exit};

fn main() {
    let current_hash = compute_content_hash();
    let cache = read_cache();
    
    match cache {
        Some(c) if c.hash == current_hash => {
            println!("[SKIP] Content unchanged since last audit");
            println!("  Last audit: {}", c.timestamp);
            println!("  Result: {}", c.result);
            exit(if c.result == "PASS" { 0 } else { 1 });
        }
        _ => {
            println!("[RUN] Content changed - full audit required");
            exit(2);
        }
    }
}

fn compute_content_hash() -> String {
    let mut hasher = Sha256::new();
    
    // Hash all tool source files (sorted for determinism)
    let mut files: Vec<_> = glob(".agent/tools/src/bin/*.rs").collect();
    files.sort();
    for file in files {
        hasher.update(fs::read_to_string(file).unwrap_or_default());
    }
    
    // Hash Cargo.toml (dependency changes matter)
    hasher.update(fs::read_to_string(".agent/tools/Cargo.toml").unwrap_or_default());
    
    // Hash workflows that reference tools (sorted for determinism)
    let mut workflows: Vec<_> = glob(".agent/workflows/*.md")
        .filter(|f| {
            let content = fs::read_to_string(f).unwrap_or_default();
            content.contains(".agent\\tools\\") || 
            content.contains(".agent/tools/") ||
            content.contains("Headless")
        })
        .collect();
    workflows.sort();
    for file in workflows {
        hasher.update(fs::read_to_string(file).unwrap_or_default());
    }
    
    hex::encode(hasher.finalize())
}
```

#### 2. Cache File: `.agent/tools/.audit_cache`

```yaml
# Auto-generated by check_tool_alignment_skip.exe
# Do not edit manually
version: 1
timestamp: "2026-01-30T21:53:00+01:00"
hash: "a7b3c9d4e5f6789012345678901234567890abcdef1234567890abcdef12345678"
result: "PASS"
findings: []
```

#### 3. Cache Writer: `write_audit_cache.rs` (or add to existing binary)

Called by the agent AFTER completing `/audit_tool_alignment`:
```rust
fn write_cache(result: &str, findings: Vec<String>) {
    let hash = compute_content_hash();
    let cache = AuditCache {
        version: 1,
        timestamp: chrono::Utc::now().to_rfc3339(),
        hash,
        result: result.to_string(),
        findings,
    };
    fs::write(".agent/tools/.audit_cache", serde_yaml::to_string(&cache)?)?;
}
```

---

### Workflow Integration

#### Update: `.agent/workflows/audit_tool_alignment.md`

Add at the TOP of the workflow, before any agent steps:

```markdown
---
description: Meta-governance workflow to verify alignment between agent tools and documentation. AGENT-ONLY - No headless scripting allowed.
---

# Meta Audit: Tool-Documentation Alignment

> [!CAUTION]
> **ROOT WORKFLOW — EXECUTE FIRST**

## Skip Condition (Headless Pre-Check)

// turbo
```powershell
.agent\tools\target\release\check_tool_alignment_skip.exe
```

| Exit Code | Meaning | Action |
|-----------|---------|--------|
| `0` | Hash matches, cached PASS | **SKIP entire workflow** |
| `1` | Hash matches, cached FAIL | SKIP, but report cached issues |
| `2` | Hash mismatch or no cache | **Proceed with full audit** |

> [!NOTE]
> This is the ONLY headless component of an otherwise agent-only workflow.
> After completing the full audit, the agent MUST write to `.audit_cache`.

---

## 1. Inventory: Tool Catalog
... (rest of workflow unchanged)
```

#### Update: `.agent/skills/agentic_philosophy/SKILL.md`

Add to the "Script-Agent Handoff" section:

```markdown
### Cache-Based Skip Pattern

For expensive agent-only workflows, a hash-based cache can avoid re-execution:

1. **Pre-Check Script**: Computes content hash, compares to cache
2. **If Match**: Skip workflow, return cached result
3. **If Mismatch**: Full agent execution, then write new cache
4. **Guarantee**: Script only checks hash — cannot make semantic decisions

This pattern applies to:
- `/audit_tool_alignment` (Phase 1.5)
```

#### Update: `.agent/skills/project_workflows/SKILL.md`

Add to Tool Catalog:

```markdown
| `check_tool_alignment_skip.rs` | Hash-based skip for root workflow | Phase 1.5 |
```

---

### Logic Breakdown: Why This Works

#### What the Hash Covers

| Content | Why Included |
|---------|--------------|
| `src/bin/*.rs` | Tool logic changes |
| `Cargo.toml` | Dependency changes affect compilation |
| Workflows with "Headless" or ".agent/tools/" | Workflow requirements may change |

#### What the Hash Does NOT Cover (And Why That's Safe)

| Not Covered | Why It's Safe |
|-------------|---------------|
| Compiled binaries | Source hash ensures rebuild if changed |
| Skill files | Tools shouldn't depend on skill content |
| Test files | Test changes don't affect tool alignment |
| Non-tool workflows | Only tool-referencing workflows matter |

---

### False Result Analysis

#### Can This Produce False Negatives? (Miss a real problem)

| Scenario | Risk | Mitigation |
|----------|------|------------|
| Tool source changes | ❌ None | Hash changes → full audit |
| Cargo.toml changes | ❌ None | Hash changes → full audit |
| Workflow requirements change | ❌ None | Workflow hash changes → full audit |
| New tool added | ❌ None | New file changes hash → full audit |
| Tool deleted | ❌ None | Missing file changes hash → full audit |
| Cache corrupted | ❌ None | Parse failure → exit(2) → full audit |
| Cache manually edited | ⚠️ Low | User responsibility; hash still re-computed |

**Conclusion**: No false negatives possible unless user manually edits cache with matching hash (extremely unlikely).

#### Can This Produce False Positives? (Unnecessary audit)

| Scenario | Impact |
|----------|--------|
| Whitespace-only changes | Full audit runs (safe but wasteful) |
| Comment-only changes | Full audit runs (safe but wasteful) |
| Cache missing | Full audit runs (correct behavior) |

**Conclusion**: False positives are possible but harmless (just less efficient).

---

### Safety Guarantees

1. **Script is Read-Only**: `check_tool_alignment_skip.exe` only reads files and cache, never modifies
2. **Agent Writes Cache**: Only the agent writes `.audit_cache` after successful audit
3. **Exit Code Protocol**: Clear semantics prevent misinterpretation
4. **Deterministic Hash**: Sorted file order ensures consistent hashing
5. **Fail-Open Design**: Any error or missing cache triggers full audit

---

### Token Savings

| Scenario | Without Skip | With Skip | Savings |
|----------|--------------|-----------|---------|
| First Run | ~27,000 | ~27,000 | 0% |
| Subsequent (no changes) | ~27,000 | **~200** | **99%** |
| Subsequent (tools changed) | ~27,000 | ~27,000 | 0% |

#### Impact on `/suite_full_audit`

| Scenario | Current | With Phase 1.5 |
|----------|---------|----------------|
| First Run | ~63,250 | ~63,250 |
| **Subsequent (No Changes)** | ~27,150 | **~350** |

---

### Implementation Checklist

- [x] Create `check_tool_alignment_skip.rs`
- [x] Add `sha2`, `hex`, `serde_yaml`, `chrono` to Cargo.toml
- [x] Build: `cargo build --release`
- [x] Update `/audit_tool_alignment.md` with skip condition
- [x] Update `agentic_philosophy/SKILL.md` with cache pattern
- [x] Update `project_workflows/SKILL.md` tool catalog
- [x] Add `.agent/tools/.audit_cache` to `.gitignore` (optional)
- [x] Test: Run audit → verify cache → run again → verify skip
- [x] Test: Modify `.rs` file → verify re-audit

---

## Phase 2: Shared Library Refactor (Medium Priority) ✅ DONE

### Problem
Currently, each binary (`src/bin/*.rs`) duplicates common logic:
- File reading & walking directories
- Parsing `Cargo.toml`, YAML, or Markdown
- Reporting formats (JSON/Text)

### Goal
Refactor common logic into a shared `src/lib.rs` while keeping **Atomic Binaries**.

### Architecture
*   `src/lib.rs` (`agent_tools` crate):
    *   `pub mod fs`: Robust file reading, `WalkDir` wrappers.
    *   `pub mod parser`: Common regex/parsing logic for frontmatter, links.
    *   `pub mod report`: Standardized output (Pass/Fail/Warn) and error handling.
*   `src/bin/*.rs`:
    *   Thin wrappers that import `agent_tools::*` and run specific logic.

### Benefits
1.  **DRY (Don't Repeat Yourself)**: Fix a bug in file reading once, update all tools.
2.  **Consistency**: All tools will output identical `[PASS]`/`[FAIL]` formats.
3.  **Atomicity Preserved**: Workflows still call specific `.exe` files.

### Implementation Checklist
- [x] Create `src/lib.rs`
- [x] Move `walkdir`, `fs` helpers to `lib.rs`
- [x] Define `AuditResult` struct in `lib.rs` for standardized reporting
- [x] Refactor `audit_dependencies` to use lib
- [x] Refactor `check_links` to use lib
- [x] Refactor `check_gherkin` to use lib
- [x] Refactor remaining tools (`check_context`, `check_constants`, `check_infrastructure`, `check_workflow_skip`)

### Results (Verified 2026-01-30)
*   **Token Efficiency**: Warm runs reduced to **~350 tokens** (99% reduction) via Phase 1.5 + 2 integration.
*   **Reliability**: Zero false positives in final verification (after excluding meta-docs).
*   **Codebase**: 8 tools refactored to use `agent_tools` shared library.
*   **Reports**: See `notes/token_efficiency_analysis_v7_phase2.md` and `notes/alignment_report.md`.


---

## Phase 3: Pre-Commit Integration (Medium Priority)

### Goal
Enforce health checks before every git commit.

**Implementation**:
1.  Add `.git/hooks/pre-commit` that runs `run_full_audit.sh`
2.  Block commits with exit code 1

**Benefits**: Pre-emptive self-healing (Level 3 in philosophy).

---

## Phase 4: Sentinel Automation (Lower Priority)

### Goal
Implement proactive watchers for drift detection.

| Sentinel | Function |
|----------|----------|
| **Catalog Sentinel** | Auto-update `project_workflows` on file creation |
| **Dead Skill Detector** | Flag skills with no references |
| **Orphan Doc Detector** | Flag docs not linked from skills |

**Implementation**: File system watcher (Rust `notify` crate) or Git hook.

---

## Phase 5: Metrics & Comparison (Lower Priority)

### Goal
Track real-world token usage for validation.

**Metrics to Track**:
*   Tokens per `/suite_full_audit` run
*   Manual fallback trigger rate
*   Time-to-detection for regressions

**Compare Against**: `notes/token_efficiency_milestone.md` baseline.

---

## Success Criteria

| Phase | Metric | Target |
|-------|--------|--------|
| 1 | Workflow script coverage | 100% |
| 2 | Shared Library Integration | 100% |
| 3 | Pre-commit hook active | Yes |
| 4 | Sentinel count | 2+ |
| 5 | Token tracking active | Yes |
