//! Dead Code Sentinel: The Reaper
//!
//! Scans valid knowledge directories and identifies "Orphan" files 
//! (files not linked by any other file).
//! 
//! Output: Generates `notes/archival_candidates.md`.

use agent_tools::prelude::*;
use std::collections::{HashSet, HashMap};
use std::path::PathBuf;
use std::fs;

fn main() {
    println!("[AUDIT] Sentinel: Dead Code (The Reaper)");
    
    // 1. Collect Definitions (Nodes)
    let targets = [".agent/skills", "docs", "notes"];
    let mut definitions = HashSet::new();
    let mut file_map = HashMap::new(); // Canonical -> RelPath
    
    for target in targets {
        let files = find_files(target, "md");
        for path in files {
            if let Ok(canon) = fs::canonicalize(&path) {
                definitions.insert(canon.clone());
                file_map.insert(canon, path);
            }
        }
    }
    
    // 2. Collect References (Edges)
    let mut references = HashSet::new();
    
    for (def_path, _rel_path) in &file_map {
        let content = read_to_string_lossy(def_path);
        let links = find_markdown_links(&content);
        
        let parent = def_path.parent().unwrap();
        
        for link in links {
            if link.starts_with("http") || link.starts_with('#') {
                continue;
            }
            // Separate anchor if present
            let clean_link = link.split('#').next().unwrap_or(&link);
            if clean_link.is_empty() { continue; }
            
            // Resolve path
            let target_path = parent.join(clean_link);
            if let Ok(canon_target) = fs::canonicalize(&target_path) {
                references.insert(canon_target);
            }
        }
    }
    
    // 3. Find Orphans
    let mut orphans = Vec::new();
    for def in &definitions {
        if !references.contains(def) {
            orphans.push(def);
        }
    }
    
    // 4. Filter Roots
    let roots = ["README.md", "SKILL.md", "project_details.md", "constants.yml", "archival_candidates.md"];
    orphans.retain(|path| {
        let name = path.file_name().unwrap_or_default().to_string_lossy();
        !roots.iter().any(|r| name.eq_ignore_ascii_case(r))
    });
    
    // 5. Report
    if orphans.is_empty() {
        println!("[OK] No orphan files found.");
    } else {
        println!("[WW] Found {} orphan files.", orphans.len());
        generate_report(&orphans, &file_map);
    }
}

fn generate_report(orphans: &[&PathBuf], file_map: &HashMap<PathBuf, PathBuf>) {
    let mut content = String::new();
    content.push_str("# Archival Candidates (Orphans)\n\n");
    content.push_str("**Generated by**: `sentinel_dead_code`\n");
    content.push_str("**Action**: Review these files. If valuable, link them. If stale, move to `.agent/annex/`.\n\n");
    
    let mut sorted_orphans = orphans.to_vec();
    sorted_orphans.sort_by_key(|p| file_map.get(*p).unwrap().to_string_lossy().to_string());

    for path in sorted_orphans {
        let rel = file_map.get(path).unwrap().display();
        content.push_str(&format!("*   [ ] {}\n", rel));
    }
    
    if let Err(e) = fs::write("notes/archival_candidates.md", content) {
        eprintln!("[XX] Failed to write report: {}", e);
    } else {
        println!("[OK] Report generated: notes/archival_candidates.md");
    }
}
